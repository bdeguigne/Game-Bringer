{"ast":null,"code":"import { getFilterRequest, searchByNameRequest, searchRequest, correctIdsRequest } from '../services/filtersService';\nimport { filtersConstants } from '../constants/filtersConstants';\nimport { findDeveloper, getElapsedTime } from '../../utils/requestFormat';\nimport moment from 'moment';\nexport const getFilters = () => {\n  return dispatch => {\n    getFilterRequest().then(res => res.json()).then(res => {\n      let genres = [];\n      let modes = [];\n      let perspective = []; // console.log(\"GET FILTERS RESULT \", res);\n\n      res.forEach(element => {\n        if (element.name === \"Genres\") {\n          genres = element.result;\n        } else if (element.name === \"Modes\") {\n          modes = element.result;\n        } else if (element.name === \"Perspectives\") {\n          perspective = element.result;\n        } else {\n          console.log(\"getFilters error\");\n        }\n      });\n      dispatch({\n        type: filtersConstants.GET_GENRES,\n        data: genres\n      });\n      dispatch({\n        type: filtersConstants.GET_MODES,\n        data: modes\n      });\n      dispatch({\n        type: filtersConstants.GET_PERSPECTIVE,\n        data: perspective\n      });\n    }).catch(error => console.log(\"getFilters error\", error));\n  };\n};\nexport const searchByName = (endpoint, searchEntry, slug, exclude) => {\n  return dispatch => {\n    dispatch({\n      type: filtersConstants.TEXTFIELDS_RES_REQUEST\n    });\n    searchByNameRequest(endpoint, searchEntry, exclude).then(res => res.json()).then(res => {\n      // console.log(\"SEARCH BY NAME RES\", slug);\n      dispatch({\n        type: filtersConstants.SET_TEXTFIELDS_SEARCH_RES,\n        res: {\n          [slug]: res\n        }\n      });\n    }).catch(error => console.log(\"getFilters error\", error));\n  };\n};\nexport const correctIds = needRequestArray => {\n  const genQuery = () => {\n    console.log(\"REDUX \", needRequestArray);\n    const queryData = [];\n    needRequestArray.forEach(filter => {\n      if (filter.slug === \"companies\") {\n        queryData.push({\n          endpoint: \"involved_companies\",\n          name: filter.slug,\n          fields: \"company.name\",\n          condition: `company = (${filter.ids.join(\",\")})`\n        });\n      } else {\n        queryData.push({\n          endpoint: `${filter.slug}`,\n          name: filter.slug,\n          fields: \"name\",\n          condition: `id = (${filter.ids.join(\",\")})`\n        });\n      }\n    });\n    return queryData;\n  };\n\n  return dispatch => {\n    const queryData = genQuery();\n    console.log(\"QUERY GEN\", queryData);\n    correctIdsRequest(queryData).then(res => res.json()).then(res => {\n      console.log(\"CORRECT IDS RES\", res);\n      dispatch({\n        type: filtersConstants.SET_CORRECT_IDS,\n        data: res\n      });\n    }).catch(err => console.log(\"error CorrectIds\", err));\n  };\n};\nexport const search = filters => {\n  function generateFilterQuery() {\n    let filtersQueryArray = [];\n\n    if (filters) {\n      Object.keys(filters).forEach(key => {\n        // console.log(\"OBJ\", key);\n        switch (key) {\n          case \"term\":\n            const searchTerm = `name ~ *\"${filters[key]}\"*`;\n            filtersQueryArray.push(searchTerm);\n            break;\n\n          case \"rating\":\n            const [min, max] = filters[key].split(\",\");\n            const formatFiltersRates = `aggregated_rating >= ${min} & aggregated_rating <= ${max} & aggregated_rating != null`;\n            filtersQueryArray.push(formatFiltersRates);\n            break;\n\n          case \"companies\":\n            const formatFiltersCompanies = \"involved_companies.company = (\" + filters[key].split(\",\").map(filter => `${filter}`).join(',') + \")\";\n            filtersQueryArray.push(formatFiltersCompanies);\n            break;\n\n          case \"year\":\n            const years = filters[key].split(\",\");\n            const datesQuery = [];\n            years.forEach(year => {\n              const unixYear = moment({\n                year\n              }).format(\"X\");\n              const unixYearEnd = moment({\n                year\n              }).add(1, 'y').format(\"X\");\n              const dateQuery = `first_release_date >= ${unixYear} & first_release_date <= ${unixYearEnd}`;\n              datesQuery.push(dateQuery);\n            });\n            filtersQueryArray.push(datesQuery.join(\" | \"));\n            break;\n\n          default:\n            if (filters[key] !== \"\") {\n              const formatFilters = key + \" = [\" + filters[key].split(\",\").map(filter => `${filter}`).join(',') + \"]\";\n              filtersQueryArray.push(formatFilters);\n            }\n\n        }\n      });\n    }\n\n    const filtersQuery = filtersQueryArray.join(\" & \");\n    return filtersQuery !== \"\" ? filtersQuery : null;\n  }\n\n  return dispatch => {\n    const query = generateFilterQuery();\n    searchRequest(query).then(res => res.json()).then(res => {\n      let searchResults = [];\n      res.forEach(game => {\n        const name = game.name;\n        const company = findDeveloper(game.involved_companies);\n        const releaseDate = getElapsedTime(game.release_dates, game.first_release_date);\n        const platforms = game.platforms;\n        const coverID = game.cover ? game.cover.image_id : null;\n        const rating = Math.round(game.aggregated_rating);\n        searchResults.push({\n          name,\n          company,\n          releaseDate,\n          platforms,\n          coverID,\n          rating\n        });\n      }); // console.log(\"SEARCH RES\", searchResults);\n\n      dispatch({\n        type: filtersConstants.SET_SEARCH_RESULTS,\n        data: searchResults\n      });\n    }).catch(err => console.log(\"search error\", err));\n  };\n};","map":{"version":3,"sources":["/Users/bdeguigne/Documents/Game Bringer/src/redux/actions/filtersActions.js"],"names":["getFilterRequest","searchByNameRequest","searchRequest","correctIdsRequest","filtersConstants","findDeveloper","getElapsedTime","moment","getFilters","dispatch","then","res","json","genres","modes","perspective","forEach","element","name","result","console","log","type","GET_GENRES","data","GET_MODES","GET_PERSPECTIVE","catch","error","searchByName","endpoint","searchEntry","slug","exclude","TEXTFIELDS_RES_REQUEST","SET_TEXTFIELDS_SEARCH_RES","correctIds","needRequestArray","genQuery","queryData","filter","push","fields","condition","ids","join","SET_CORRECT_IDS","err","search","filters","generateFilterQuery","filtersQueryArray","Object","keys","key","searchTerm","min","max","split","formatFiltersRates","formatFiltersCompanies","map","years","datesQuery","year","unixYear","format","unixYearEnd","add","dateQuery","formatFilters","filtersQuery","query","searchResults","game","company","involved_companies","releaseDate","release_dates","first_release_date","platforms","coverID","cover","image_id","rating","Math","round","aggregated_rating","SET_SEARCH_RESULTS"],"mappings":"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","sourcesContent":["import { getFilterRequest, searchByNameRequest, searchRequest, correctIdsRequest } from '../services/filtersService';\nimport { filtersConstants } from '../constants/filtersConstants'\nimport { findDeveloper, getElapsedTime } from '../../utils/requestFormat';\nimport moment from 'moment';\n\nexport const getFilters = () => {\n    return (dispatch) => {\n        getFilterRequest()\n            .then(res => res.json())\n            .then(res => {\n                let genres = [];\n                let modes = [];\n                let perspective = [];\n\n                // console.log(\"GET FILTERS RESULT \", res);\n                res.forEach(element => {\n                    if (element.name === \"Genres\") {\n                        genres = element.result\n                    } else if (element.name === \"Modes\") {\n                        modes = element.result;\n                    } else if (element.name === \"Perspectives\") {\n                        perspective = element.result;\n                    } else {\n                        console.log(\"getFilters error\");\n                    }\n                });\n\n                dispatch({\n                    type: filtersConstants.GET_GENRES,\n                    data: genres\n                })\n                dispatch({\n                    type: filtersConstants.GET_MODES,\n                    data: modes\n                })\n                dispatch({\n                    type: filtersConstants.GET_PERSPECTIVE,\n                    data: perspective\n                })\n\n            })\n            .catch(error => console.log(\"getFilters error\", error))\n    }\n}\n\nexport const searchByName = (endpoint, searchEntry, slug, exclude) => {\n    return (dispatch) => {\n        dispatch({\n            type: filtersConstants.TEXTFIELDS_RES_REQUEST\n        })\n        searchByNameRequest(endpoint, searchEntry, exclude)\n            .then(res => res.json())\n            .then(res => {\n                // console.log(\"SEARCH BY NAME RES\", slug);\n\n                dispatch({\n                    type: filtersConstants.SET_TEXTFIELDS_SEARCH_RES,\n                    res: {\n                        [slug]: res\n                    }\n                })\n            })\n            .catch(error => console.log(\"getFilters error\", error))\n    }\n}\n\nexport const correctIds = (needRequestArray) => {\n    const genQuery = () => {\n        console.log(\"REDUX \", needRequestArray)\n        const queryData = []\n\n        needRequestArray.forEach(filter => {\n            if (filter.slug === \"companies\") {\n                queryData.push({\n                    endpoint: \"involved_companies\",\n                    name: filter.slug,\n                    fields: \"company.name\",\n                    condition: `company = (${filter.ids.join(\",\")})`\n                })\n            } else {\n                queryData.push({\n                    endpoint: `${filter.slug}`,\n                    name: filter.slug,\n                    fields: \"name\",\n                    condition: `id = (${filter.ids.join(\",\")})`\n                })\n            }\n        })\n\n        return queryData;\n    }\n\n    return (dispatch) => {\n        const queryData = genQuery();\n        console.log(\"QUERY GEN\", queryData);\n        correctIdsRequest(queryData)\n            .then(res => res.json())\n            .then(res => {\n                console.log(\"CORRECT IDS RES\", res);\n                dispatch({\n                    type: filtersConstants.SET_CORRECT_IDS,\n                    data: res\n                })\n            })\n            .catch(err => console.log(\"error CorrectIds\", err))\n    }\n}\n\nexport const search = (filters) => {\n    function generateFilterQuery() {\n\n        let filtersQueryArray = [];\n\n        if (filters) {\n            Object.keys(filters).forEach(key => {\n                // console.log(\"OBJ\", key);\n\n                switch (key) {\n                    case \"term\":\n                        const searchTerm = `name ~ *\"${filters[key]}\"*`;\n                        filtersQueryArray.push(searchTerm);\n                        break;\n                    case \"rating\":\n                        const [min, max] = filters[key].split(\",\");\n\n                        const formatFiltersRates = `aggregated_rating >= ${min} & aggregated_rating <= ${max} & aggregated_rating != null`;\n                        filtersQueryArray.push(formatFiltersRates);\n                        break\n                    case \"companies\":\n                        const formatFiltersCompanies = \"involved_companies.company = (\" + filters[key].split(\",\").map(filter => `${filter}`).join(',') + \")\";\n                        filtersQueryArray.push(formatFiltersCompanies);\n                        break;\n                    case \"year\":\n                        const years = filters[key].split(\",\");\n                        const datesQuery = []\n\n                        years.forEach(year => {\n                            const unixYear = moment({ year }).format(\"X\");\n                            const unixYearEnd = moment({ year }).add(1, 'y').format(\"X\");\n                            const dateQuery = `first_release_date >= ${unixYear} & first_release_date <= ${unixYearEnd}`;\n                            datesQuery.push(dateQuery);\n                        })\n                        filtersQueryArray.push(datesQuery.join(\" | \"));\n                        break;\n                    default:\n                        if (filters[key] !== \"\") {\n                            const formatFilters = key + \" = [\" + filters[key].split(\",\").map(filter => `${filter}`).join(',') + \"]\";\n                            filtersQueryArray.push(formatFilters);\n                        }\n                }\n            })\n        }\n\n        const filtersQuery = filtersQueryArray.join(\" & \");\n\n        return filtersQuery !== \"\" ? filtersQuery : null;\n    }\n\n    return (dispatch) => {\n        const query = generateFilterQuery();\n\n        searchRequest(query)\n            .then(res => res.json())\n            .then(res => {\n                let searchResults = [];\n\n                res.forEach(game => {\n                    const name = game.name;\n                    const company = findDeveloper(game.involved_companies);\n                    const releaseDate = getElapsedTime(game.release_dates, game.first_release_date);\n                    const platforms = game.platforms;\n                    const coverID = game.cover ? game.cover.image_id : null;\n                    const rating = Math.round(game.aggregated_rating);\n\n                    searchResults.push({\n                        name,\n                        company,\n                        releaseDate,\n                        platforms,\n                        coverID,\n                        rating\n                    })\n                })\n                // console.log(\"SEARCH RES\", searchResults);\n                dispatch({\n                    type: filtersConstants.SET_SEARCH_RESULTS,\n                    data: searchResults\n                })\n            })\n            .catch(err => console.log(\"search error\", err))\n    }\n\n}"]},"metadata":{},"sourceType":"module"}